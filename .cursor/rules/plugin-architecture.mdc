---
description: Plugin architecture patterns and implementation guidelines
globs: src/plugins/**/*
---

# Plugin Architecture Guidelines

## Plugin Implementation Pattern

### Core Plugin Structure

Every plugin should follow this structure in `src/plugins/[plugin-name]/`:

```typescript
// index.ts - Main export file
export { PluginName } from './plugin';
export * from './react'; // if applicable
export * from './command'; // if applicable
export * from './service'; // if applicable
export * from './node'; // if applicable
```

### Plugin Class Implementation

Base plugin class in `plugin/index.ts`:

```typescript
export const PluginName: IEditorPluginConstructor<PluginOptions> = class
  extends KernelPlugin
  implements IEditorPlugin<PluginOptions>
{
  static pluginName = 'PluginName';
  
  constructor(
    protected kernel: IEditorKernel,
    public config?: PluginOptions,
  ) {
    super();
    // Register services, nodes, themes
    // kernel.registerService(IServiceName, new ServiceImpl());
    // kernel.registerNodes([CustomNode]);
    // kernel.registerThemes(config?.theme);
  }

  onInit(editor: LexicalEditor): void {
    // Register commands, listeners, observers
    // this.register(registerCustomCommand(editor));
  }
};
```

## Service Pattern

### Service Definition

Services should implement interfaces in `service/`:

```typescript
// Interface definition
export interface ICustomService {
  method1(param: Type): ReturnType;
  method2(param: Type): Promise<ReturnType>;
}

export const ICustomService: IServiceID<ICustomService> = 
  genServiceId<ICustomService>('CustomService');

// Implementation
export class CustomService implements ICustomService {
  // Implementation details
}
```

### Service Registration

Register services in plugin constructor:

```typescript
kernel.registerService(ICustomService, new CustomService());
```

## Command Pattern

### Command Definition

Define commands in `command/index.ts`:

```typescript
export const CUSTOM_COMMAND = createCommand<PayloadType>('CUSTOM_COMMAND');

export function registerCustomCommand(editor: LexicalEditor) {
  return editor.registerCommand(
    CUSTOM_COMMAND,
    (payload) => {
      // Command implementation
      return true; // Command handled
    },
    COMMAND_PRIORITY_HIGH,
  );
}
```

## Node System

### Custom Nodes

Define custom nodes in `node/`:

```typescript
export class CustomNode extends DecoratorNode<any> {
  static getType(): string {
    return 'custom';
  }

  static clone(node: CustomNode): CustomNode {
    return new CustomNode(/* parameters */);
  }

  static importJSON(serializedNode: SerializedCustomNode): CustomNode {
    return new CustomNode(/* from serialized data */);
  }

  exportJSON(): SerializedCustomNode {
    return {
      // Serialization data
    };
  }

  createDOM(config: EditorConfig): HTMLElement {
    // DOM creation logic
  }
}
```

## React Integration

### React Components

React components in `react/index.tsx`:

```typescript
export const ReactCustomPlugin = memo<CustomPluginProps>(({
  // Props destructuring
}) => {
  // Component implementation
});

ReactCustomPlugin.displayName = 'ReactCustomPlugin';
```

### Type Definitions

Define props in `react/type.ts`:

```typescript
export interface CustomPluginProps {
  // Prop definitions with JSDoc comments
  /** Description of the prop */
  propName: PropType;
}
```

## Internationalization

For plugins with i18n support:

```typescript
// Import i18n in index.ts
import './i18n';

// Define translations
export const translations = {
  'custom.action': 'Action Text',
  'custom.error': 'Error Message',
};
```

## Theme System

### Theme Configuration

Define theme interfaces:

```typescript
export interface CustomTheme {
  custom?: string;
  customActive?: string;
  customDisabled?: string;
}
```

Register themes in plugin:

```typescript
kernel.registerThemes({
  custom: config.theme?.custom || 'default-custom-class',
});
```

## Best Practices

1. **Service Isolation**: Keep business logic in services
2. **Command Responsibility**: One command per operation
3. **Node Specialization**: Custom nodes for specific content types
4. **React Separation**: Keep React logic separate from core plugin
5. **Error Handling**: Comprehensive error handling in all layers
6. **Type Safety**: Full TypeScript coverage with proper interfaces
7. **Documentation**: Comprehensive inline documentation
