---
description: React component development guidelines for LobeHub Editor
globs: src/react/**/*,src/plugins/*/react/**/*
---

# React Component Guidelines

## Component Structure Standards

### High-Level Components (`src/react/`)

These are the main user-facing components:

- [Editor](mdc:src/react/Editor/) - Primary editor component with plugin system
- [ChatInput](mdc:src/react/ChatInput/) - Chat interface container
- [ChatInputActions](mdc:src/react/ChatInputActions/) - Action management system
- [ChatInputActionBar](mdc:src/react/ChatInputActionBar/) - Action layout component
- [SendButton](mdc:src/react/SendButton/) - Send button with states
- [CodeLanguageSelect](mdc:src/react/CodeLanguageSelect/) - Language selection

### Plugin React Components (`src/plugins/*/react/`)

Plugin-specific React implementations that integrate with the core system.

## Component Development Pattern

### Component Definition

```typescript
// Component props interface
export interface ComponentNameProps {
  /** Required prop with description */
  requiredProp: string;
  /** Optional prop with default */
  optionalProp?: boolean;
  /** Event handler */
  onEvent?: (data: EventData) => void;
  /** Children for composition */
  children?: ReactNode;
  /** Style customization */
  className?: string;
  style?: CSSProperties;
}

// Component implementation
export const ComponentName = memo<ComponentNameProps>(({
  requiredProp,
  optionalProp = false,
  onEvent,
  children,
  className,
  style,
  ...rest
}) => {
  // Hooks and state
  const [state, setState] = useState(initialValue);
  const { styles, cx } = useStyles();
  
  // Event handlers
  const handleEvent = useCallback((data: EventData) => {
    // Event logic
    onEvent?.(data);
  }, [onEvent]);
  
  // Render
  return (
    <div 
      className={cx(styles.container, className)}
      style={style}
      {...rest}
    >
      {children}
    </div>
  );
});

ComponentName.displayName = 'ComponentName';
```

### Plugin Component Pattern

```typescript
// Plugin-specific props
export interface ReactPluginNameProps {
  /** Plugin-specific configuration */
  config?: PluginConfig;
  /** Editor reference for commands */
  editor?: LexicalEditor;
  /** Plugin state */
  state?: PluginState;
  /** Plugin callbacks */
  onPluginEvent?: (event: PluginEvent) => void;
}

export const ReactPluginName = memo<ReactPluginNameProps>(({
  config,
  editor,
  state,
  onPluginEvent,
}) => {
  // Plugin-specific logic
  const pluginService = usePluginService();
  
  // Command dispatch
  const handleCommand = useCallback((command: Command, payload: any) => {
    editor?.dispatchCommand(command, payload);
  }, [editor]);
  
  return (
    <PluginContainer>
      {/* Plugin UI */}
    </PluginContainer>
  );
});
```

## Editor Integration

### Editor Component Usage

```typescript
import { Editor } from '@lobehub/editor/react';
import { 
  ReactSlashPlugin, 
  ReactMentionPlugin,
  ReactCodeblockPlugin 
} from '@lobehub/editor';

function MyEditor() {
  const editorRef = Editor.useEditor();
  
  return (
    <Editor
      editorRef={editorRef}
      placeholder="Start typing..."
      plugins={[
        ReactSlashPlugin,
        ReactMentionPlugin,
        ReactCodeblockPlugin,
      ]}
      slashOption={{
        items: slashItems,
      }}
      mentionOption={{
        items: mentionItems,
      }}
      onChange={(editor) => {
        // Handle changes
      }}
    />
  );
}
```

### Chat Interface Pattern

```typescript
function ChatInterface() {
  return (
    <ChatInput
      header={<ChatHeader />}
      footer={
        <ChatInputActionBar
          left={<ChatInputActions items={leftActions} />}
          right={<SendButton onSend={handleSend} />}
        />
      }
    >
      <Editor {...editorProps} />
    </ChatInput>
  );
}
```

## Styling Guidelines

### Style Hooks Pattern

```typescript
import { createStyles } from '@lobehub/ui';

const useStyles = createStyles(({ css, token }) => ({
  container: css`
    padding: ${token.padding}px;
    border-radius: ${token.borderRadius}px;
    background: ${token.colorBgContainer};
  `,
  
  active: css`
    background: ${token.colorPrimary};
    color: ${token.colorTextLightSolid};
  `,
}));
```

### Theme Integration

```typescript
// Use theme tokens
const useStyles = createStyles(({ css, token, isDarkMode }) => ({
  component: css`
    background: ${isDarkMode ? token.colorBgElevated : token.colorBgContainer};
    border: 1px solid ${token.colorBorder};
    
    &:hover {
      border-color: ${token.colorPrimary};
    }
  `,
}));
```

## Event Handling

### Command Integration

```typescript
const ComponentWithCommands = memo(() => {
  const editor = useEditor();
  
  const handleAction = useCallback((action: ActionType) => {
    switch (action.type) {
      case 'insert-heading':
        editor.dispatchCommand(INSERT_HEADING_COMMAND, { tag: 'h1' });
        break;
      case 'insert-list':
        editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND);
        break;
    }
  }, [editor]);
  
  return <ActionButton onAction={handleAction} />;
});
```

### State Management

```typescript
const StatefulComponent = memo(() => {
  // Local state
  const [isOpen, setIsOpen] = useState(false);
  
  // External state
  const editorState = useEditorState();
  
  // Derived state
  const canSave = useMemo(() => {
    return editorState.hasContent && !editorState.isLoading;
  }, [editorState.hasContent, editorState.isLoading]);
  
  return (
    <div>
      <Button 
        disabled={!canSave}
        onClick={() => setIsOpen(true)}
      >
        Save
      </Button>
    </div>
  );
});
```

## Testing Components

### Component Testing

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  it('should render with required props', () => {
    render(<ComponentName requiredProp="test" />);
    expect(screen.getByText('test')).toBeInTheDocument();
  });
  
  it('should handle events', () => {
    const handleEvent = jest.fn();
    render(<ComponentName onEvent={handleEvent} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleEvent).toHaveBeenCalledWith(expectedData);
  });
});
```

## Performance Optimization

### Memoization

```typescript
const OptimizedComponent = memo<Props>(({ items, onSelect }) => {
  // Memoize expensive calculations
  const processedItems = useMemo(() => {
    return items.map(processItem);
  }, [items]);
  
  // Memoize callbacks
  const handleSelect = useCallback((item: Item) => {
    onSelect?.(item);
  }, [onSelect]);
  
  return (
    <ItemList 
      items={processedItems}
      onSelect={handleSelect}
    />
  );
});
```

### Virtualization

```typescript
const VirtualizedList = memo<{ items: Item[] }>(({ items }) => {
  return (
    <VirtualList
      height={400}
      itemCount={items.length}
      itemSize={50}
      itemData={items}
    >
      {({ index, style, data }) => (
        <div style={style}>
          <ItemRenderer item={data[index]} />
        </div>
      )}
    </VirtualList>
  );
});
```
